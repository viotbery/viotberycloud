---
title: 栈与队列
mathjax: true
cover: https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ图片20220105151908.png
---

# 栈

> 栈是一个只能在栈定进行操作的数据结构，根据位置，最上面的称为 top,底部的元素称为bottom。LIFO:：Last In First Out 
## 栈的操作
1. **压栈(push)**
将元素置于栈的最上方，是栈的插入方式
2. **出栈(pop)**
将最上方的元素top取出，下一元素成为top
3. **读栈(top)**
读写top的值

## 栈的实现
栈可以由向量或者列表进行派生，需要注意的是，虽然理论上可以将向量的前面或后面设置成top，但实际上若以向量的的vector[0]作为top，那么之后进行的pop()或push()都将影响后面的元素，导致复杂度由O( $n^2$ )

## 栈的应用
### 应用场合
1. 逆序输出Conversion
    > 输出次序与处理过程**颠倒**，递归深度和输出长度不易预知

    #### 进制转换
``` C
int binary(int tempValue)
{
    stack bin;
    bin.size = 0;
    bin.num = (int*)malloc(sizeof(int) * N);
    bin.capacity = N;
    while(tempValue != 0)
    {   
        push(&bin, tempValue % 2);
        tempValue /= 2;
    }
    while(top(&bin) != NULL)
    {
        printf("%d", *top(&bin));
        pop(&bin);
    }
    printf("\n");
}
```

2. 递归嵌套stack permutation
    > 具有自**相似性**的问题可递归描述，但分支位置和嵌套深度不固定

    ####括号匹配
```C
int paren(char str[], int n)
{   
    //初始化
    int i=0;
    stack stack_temp;//创建栈
    stack_temp.str = (char*)malloc(sizeof(char) * N);
    stack_temp.size = 0;
    stack_temp.capacity = N;
    while (i < n)//进行线性扫描
    {
        if (str[i] == '(')//若是"("，则入栈
            push(&stack_temp, '(');
        else if (stack_temp.size != 0)//若是")"且栈非空，则出栈
            pop(&stack_temp);
        else //若是")"且栈已空，则无法匹配直接返回
            return 0;
        i++;
    }
    return stack_temp.size==0;//扫描完毕后栈以空则返回成功
}
```

#### 栈混洗
> 按照某种约定的规则，对栈中元素进行排列，约定<a1, a2, a3, ..., an] = A,其中"<"表示栈顶，"]"表示栈底。通过借助一个中转栈S，临时保存一些栈A的元素，使栈A的元素可以按照一定规则重新保存至栈B
##### 栈混洗的排列结果
当中转栈为空时，AB栈的各自排列是独立的，那么总的栈混洗数就是两个相互独立的栈混洗数的乘积，对于某一次的混洗，发生的次序不同，但仍保持在k = 1 ~ n。所以对于总共的栈混洗数，有这样的递推式：
$$\sum_{k=1}^n SP(k-1) × SP(n-k)$$
其解正是Catalan数

$$Catalan(n) = \frac{(2n)!}{(n+1)!\times n!}$$





### 栈混洗的甄别问题
>对于一个输入序列的任何一个排列，判断是否为栈混洗的一个排列
####为什么会出现这种问题？
对于一般情况下例如`<1, 2, 3]=A`,全排列有`3!`次，但栈混洗数仅有`6!/4!/3!=5`种，其中`[3, 1, 2 >`不是栈混洗。这里的元素仅代表次序关系，**任意三个元素能否按照某相对次序出现在栈混洗中吗，，与其他元素无关**，所以对于这种情况，进行推广：
>对于任何的$1\leq i<j<k\leq n$,[..., k, .., i, .., j,..>必 非栈混洗排列又称**禁形**
**仅不存在禁形是栈混洗排列的充分必要条件**

由此推论，可以进一步得出这样一个推论：
>[$p_1, p_2, p_3,..., p_n$>是<$1, 2, 3, 4, ..., n$]的栈混洗，**当且仅当**对于任意的 $i<j$,不含形如[$..., j+1, ..., i, ..., j,...$>
如此可得一个$O(n^2)$的甄别算法

改进算法$O(n)$:直接借助栈AB和S，模拟混洗过程，每次出栈前，检测S是否为空；或者需出栈的元素在S中，但并非顶元素。
``` C
    for(i = 0; i < size * 2; i++)
    {
        if (A.size != 0 && *top(&A) == result[j])
        {
            push(&B, *top(&A));
            pop(&A);
            j++;            
        }
        else if (S.size != 0 && *top(&S) == result[j])
        {
            push(&B, *top(&S));
            pop(&S);
            j++;            
        }
        else if (A.size != 0 && *top(&A) != result[j])
        {
            push(&S, *top(&A));
            pop(&A);                  
        }
        else return j == size;
    }
```
与之前的括号匹配进行对比，不难发现：栈混洗的出栈入栈操作与括号匹配的出栈入栈操作如出一辙，实际上，二者是统一的，合法的栈混洗有多少种，相应的合法括号匹配就有多少种

3. 延迟缓冲
    > 线性扫描算法模式中，在预读足够长度之后，方能确定可处理的前缀

    ##### 中缀表达式
    > 输入一串带运算符的算式，输出运算结果。主要原理是使用两个栈结构AB，A用于接受运算符：遇到优先级高的运算符时入栈，遇到优先级低的运算符时对之前优先级高的运算符进行计算，并将高级运算符出栈，低级运算符入栈。B用于接受数字，接受数字后入栈，若高于一位数字对几位数字进行处理再入栈。若涉及到计算，则将参与计算的数出栈，将结果入栈。
    
4. 栈式计算
    > 基于栈结构的特定计算模式
    ##### 逆波兰表达式
    > 在由运算符和操作符组成的表达式中，不使用括号表达带优先级的运算关系。具体是先遇到的运算符先进行计算，仅使用一个辅助栈，从开始依次接受逆波兰表达式中的运算式，在接受到运算符后，对辅助栈的一个（单目）或两个（双目）数字进行运算然后结果入栈。

逆波兰表达式是一种对于机器运算十分高效的运算方式，如何将中缀表达式转换为逆波兰表达式对效率和逻辑提升而言是很有必要的。

![逆波兰表达式的转换](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ图片20220105151908.png )
  通过转换原理可知，中缀表达式转换到逆波兰表达式仅更改运算符的相对次序，而不会更改运算数的相对次序



----------
# 队列
> 队列（queue）也是受限的序列（先进先出FIFO，后进后出LILO）
只能在**队尾**插入或查询：enqueue(),rear()
只能在**队头**删除或查询: dequeue(),front()

![队列](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ截图20220105153200.png )
## 队列的操作接口
![队列的操作接口](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ截图20220105153606.png)

队列使用列表实现会比向量更具的高效

