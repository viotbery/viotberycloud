---
title: 图
mathjax: true
cover: https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/StructureGraph.jpg
---

# 图

标签 ： 数据结构

---

## 概述
> 令 $G = (V; E)$，v为顶点，存在关系则用边E连接。彼此存在这种关系，并且因此存在连边的任何两个点， 都称为邻接关系(v - v)，参与定义这样邻接关系的每一个顶点与邻接关系之间的关系称为关联关系（v- e）
因此，线性结构列表向量、半线性结构树是图的特殊情况。
>若邻接顶点u与v的次序无所谓，则(u,v)称为**无向边**
>所有边均无方向的图称为**无向图**()_
>所有边均为有向边称为**有向边**，u,v分别称作(u,v)的**尾**、**头**
> 既含有有向边又含有无向边称为**混合图**
*通过有向图可以表示另外两种图*
### 几个基本概念
> 入度(indegree)：有向图中某点作为图中边的终点的总次数
> 出度(outdegree):某点作为图中边的起点的总次数
### 路径
> 一系列顶点按照依次邻接关系构成的一个序列
路径$\pi = <v_0, v_1, ...., v_k>$
长度$|\pi| = k$

#### 简单路径
> 一条路径中不含重复的顶点

#### 环路
> 路径起点与终点是同一节点

#### 有向无环图（DAG）
> 一个图中不含任何环路

### 欧拉环路
特别的，若一个图中的环路覆盖了所有的边，且仅经过一次，称为欧拉环路





![欧拉环路](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111120002.png)

### 哈密尔顿环路
> 经过所有的顶点一次，且恰好一次称为哈密尔顿环路

![哈密尔顿环路](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111120155.png)
## 表示图
### 接口
```C
//陈姥姥的接口
Graph Create();//建立并返回空图
Graph InsertVertex(Graph G, Vertex v);//将v插入G
Graph InsertEdge(Graph G, Edge e);//将e插入G
void DFS();//从顶点v出发深度优先遍历图G
void BFS();//从顶点v出发宽度优先遍历图G
void ShortestPath(Graph G, Vertex v, int Dist[]);//计算顶点v到其他任意顶点的最短距离
void MST(Graph G);//计算G最小生成树
```
### 邻接矩阵
> 构建n行n列的矩阵，分别对于两个顶点的下标，i行j列的值代表i顶点与j顶点的邻接关系，若具有边权重，则记为权重值。对于无向图而言，邻接矩阵以对角线为对称轴，对称轴两边值雷同

![邻接矩阵](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111125056.png)
![邻接矩阵2](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111152421.png)
![实例](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111125747.png)

**如何减少存储空间？**
> 用一个长度为$N(N+1)/2$的一维数组存储下三角区域，由上到下，由左到右依次排列。查找 i-j对应的值在一维数组里的位置可以用$rank = (i×(i+1)/2 + j)$
![转换](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111153025.png)

#### 顶点操作
枚举所有的邻接顶点
> 以邻接矩阵为例，枚举邻居实际上就是从邻居矩阵的某一行，从行末开始判断是否是邻居，否 则跳过，是则返回该邻居
```C
//利用邻接矩阵枚举
int nextNbr(int i, int j)//若以枚举至邻居j，则转向下一个邻居
{
    while ( (-1 < j) && !exists(i, --j));//逆向顺序查找 O(n)
    return j;
}
int firstNbr(int i)
{
    return nextNbr(i, n);
}//返回首个邻居
```
顶点插入

#### 边操作
创建一条边E
```C
typedef struct ENode *PtrToENode;
struct ENode 
{
    int v1,v2;
    weightType Weight;//权重
};
typedef PtrENode Edge;
```
判断边是否存在
```C
bool exists(int i, int j)//判断边ij是否存在
{
    return (0 <= i) && (i < n) && ( 0 <= j) && ( j < n) && E[i][j] != NULL;//短路求值这里二维数组赋值为null是c++的写法
}
```

边插入
```C
void InsertEdge( MGragh Graph, Edge E )
{   
    if (exists(i, j)) return;//忽略已有的边
    //插入边<v1,v2>
    Gragh->G[E->v1][E->v2] = E->Weight;
    //若是无向图，还要插入<v2, v1>
    Gragh->G[E->v2][E->v1] = E->Weight;
    //对于定义了入度，出度的图来说，应该还需更改图的入度出度
}
```
边删除
```C
ENode remove(MGragh Graph, Edge E)
{
    ENodeBak = *E;//备份信息
    Gragh->G[E->v1][E->v2] = 0;//暂时赋值为0
    //对于定义了入度，出度的图来说，应该还需更改图的入度出度
    return ENdoeBak;//语义返回该边的信息
}
```
#### 评价
*好处*
- 直观、简单、好理解
- 方便检查任意一对顶点间是否存在边
- 方便找任一顶点的所有“邻接点”（有边直接相连的顶点）
- 方便计算任一顶点的“度”
    - 无向图：对应行（或列）非0元素的个数
    - 有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度”
    *缺陷*
- 浪费空间-存稀疏图（点很多而边很少）有大量无效元素对稠密图（特别是完全图）还是很合算的
- 浪费时间-统计稀疏图中一共有多少条边

#### 邻接表
> 使用一个容量为N的一维指针数组，在每个位置上存储该节点与相邻的所有元素的链表的指针，不强调链表中的顶点的相互次序。对于特别稀疏的图来说可以节省空间。
空间需求$N + 2E$
### 关联矩阵
> 构建n行e列的矩阵，分别对于顶点与边，若顶点与某条边存在关联关系，则记为1，反之为0,。不难发现，对于一条边来说，只有两个顶点的值恰好为1

![关联矩阵](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111125047.png)

## 图的遍历
> 把图中每一个节点访问以便，且不能有重复的访问

### 深度优先搜索（DFS）
> 从起点开始，递归地判断当前节点的邻接节点是否都被访问，若没有则进入该节点继续进行判断，若所有都被访问，则递归返回到上一层.是树的先序遍历的推广
用邻接矩阵$O(n^2)$
用邻接表$O(N + E)$
![深度遍历](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111163655.png)

### 广度优先搜索(BFS)
>确定一个点为起点并访问，使用队列将改顶点的邻居逐个入队，再对队列的顶点做相同的操作。是树的层次遍历的推广，进行遍历后，经过的所有的路径与顶点构成了一个树，称为**支撑树**。
用邻接矩阵$O(n^2)$
用邻接表$O(N + E)$
![广度优先遍历](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220111163410.png)

**广度优先搜索对于寻找最短路径问题很有帮助，但二者具体的取舍还要看实际问题**

### 不连通的图
#### 连通分量(无向图)
> 在一个不连通的图中，一个部分连通的子图构成一个连通分量。即无向图的*极大*连通子图

 - 极大顶点数：再加一个顶点就不连通
 - 极大边数：包含子图中所有顶点相连的所有边

#### 强连通(有向图)
> 有向图中顶点之间存在双向路径，即，v1可以到v2，v2可以到v1.则称二者强连通
强连通图： 有向图中任意两顶点均强连通
弱连通图： 将不是强连通的有向图边的方向抹掉变成无向图后是连通的则称为弱连通图
强连通分量：有向图的极大强连通子图

```C
void ListComponents(graph G)
{
    for (取出G中的每个连通分量所代表的顶点V)
    {
        if ( !visit(V) )//若V未被访问，则开始进行DFS或VFS
            DFS（v）;
    }
}
//这个效率累积仍然是线性的O(n)
```
```C
//邓公版
int v = s;//s为起始顶点
do
    if ( UNDISCOVERED == status(v) )//枚举类型，代表该节点是否被遍历
        BFS(v);
while ( s != ( v = ( ++v % n)));
//循环条件的含义是，不管从序号多少（s）开始循环，在从此序号开始一直到n-1后,会继续从[0,s）进行循环判断，以免漏掉顶点
```
## 应用
### 最短路径问题
> 在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径

第一个顶点为**源点**

最后一个顶点为**终点**
#### 单源最短路径问题
> 从某固定源点出发，求其到所有其他顶点的最短路径

- 无权图单源最短路
    >按照递增的顺序找出各个顶点的最短路
    ```C
    void Unweighted(Vertex S)
    {   //利用BFS的思想进行修改
        //定义dist数组，存放源到各个顶点的距离，初始化为-1或负无穷或正无穷以替代原BFS算法里的访问状态
        Enqueue(S, Q);
        while(!IsEmpty(Q))
        {
            V = Dequeue(Q);
            for (V的每个邻接点)
                if ( dist[W] == -1)
                {
                    dist[W] = dist[V] + 1;
                    path[W] = V;//记录到达该节点的前一个节点的标号，以便最后能回推最短路径
                    Enqueue(W, Q);
                }
        }
    }
    ```
- 有权图的单源最短路
    > 按照递增的顺序找出各个顶点的最短路

    Dijkstra算法(迪杰斯特拉算法)
    ```C
    void Dijkstra(Vertex s)
    {
        while (1)
        {
            V = 未收录顶点中dist最小者;
            if (这样的V不存在)
                break;
            collected[V] = true;
            for (V的每个邻接点W)
                if(collected[W] == false)
                    if (dist[V] + E<V,W> < dist[W])
                    {
                        dist[W] = dist[V] + E<V,W>;
                        path[W] = v;
                    }
        }
    }
    ```

#### 多源最短路径问题
> 求任意两顶点之间的最短路径
1. 直接将单源最短路算法调用|V|遍

   $T=O(|V|^3+|E|+|V|)$
   对稀疏图效果好
2. Floyd算法:定义一个矩阵$D^k[i][j]$，表示第i到第j的最小长度，但只经过编号小于等于k的顶点，从$D^0,D^1,……,D^{|V|-1}$逐步计算，当k等于v-1时就是最短路径。初始的矩阵$D^-1$应为带权的林姐姐矩阵，对角元为0.当从$D^{k-1}$递推到$D^{k}$时，会有两种情况，
   
   ①新加进来的顶点不影响当前最短路径，就保持原样$D^{k-1}=D^{k}$
   ②新加进去的顶点影响了最短路径，说明k一定在最短路径上，该最短路径必定由i到k和
   k到j两段最短路径组成$D^{k}[i][j]=D^{k-1}[i][k]+D^{k-1}[k][j]$
   
   $T=O(|V|^3)$
```C
void Floyd()
{ 
    for (i=0; i<N; i++)
        for(j=0; j<N; j++)
        { 
            D[i][j] =G[i][j]; 
            path[i][j] = -1;
        }
    for(k=0; k<N; k++ )
        for( i=0; i<N; i++)
            for(j=0; j<N; j++ )
            {
                if( D[i][k] + D[k][j] < D[i][j] ) 
                D[i][j] = D[i][k] + D[k][j];
                path[i][j] = k;
            }
}
```

### 最小生成树
> 是一颗具有V个顶点，V-1条边的无环树.包含全部顶点，V-1条边都在图里且边的权值最小.向生成树中任加一条边都一定构成回路。
> 图连通一定有最小生成树，反之也成立

#### 贪心算法
> 每一步都要权重最小的边。
##### Prim算法——让小树长大
```C
void Prim()//原理dijkstra算法相似，复杂度为O(V^2),适用于稠密图
{
    MST = {s};//初始化最小生成树，以s为根节点
    while (1)
    {
        V = 未收录顶点dist的最小者;
        if (这样的V不存在)
            break;
        for (V的每个邻接点W)
            if(dist[W] != 0)
            if ( E(v,w) < dist[W] )
            {
                dist[W] = E(v,w);
                parent[W] = V;//记录父节点
            }
    }
    if (MST中收的顶点不到|V|个)
        ERROR("生成树不存在);
}
```
##### Kruskal算法——将森林合并成树
> 初始的状况下，每一个顶点都是一颗树，不断收入边将两颗树并成一颗树
```C
void Kruskal(Graph G)//T=O(ElogE)
{
    MST = {};
    while (MST不到v-1条边 && E还有边)
    {
        从E中取出一条权重最小的边E（v,w）；//最小堆
        将E（v,w）从E中删除;
        if (E(v,w)不在MST中构成回路)//并查集
            将E（v,w）加入MST;
        else 彻底无视E（v,w）；
    }
    if (MST中收的顶点不到|V|个)
    ERROR("生成树不存在);
}
```
## 拓扑排序
> 拓扑序：如果图中从v到w有一条有向路径，则v一定排在W之前。满足此条件的顶点序列称为一个拓扑序
获得一个拓扑序的过程是**拓扑排序**，AOV（active on vertex）如果有合理的拓扑序，则必定是有向无环图（DAG）。

先输出入度为0的顶点
```C
void TopSort()
{
    for (cnt = 0; cnt < |V|; cnt++)
    {
        V = 未输出的入度为0的顶点;//随时将入度变为0的顶点放到一个容器里
        if (这样的V不存在)
        {
            Error("图中有回路");
            break;
        }
        输出V，或者记录V的输出序号
        for (V的每个邻接点W)
            Indegree[W]--;
    }
}
//优化O(|V| + |E|)
void TopSort()
{
    for (图中的每个顶点V)
        if (Indegree[V] == 0)
            Enqueue(v,Q);
    while (!IsEmpty(Q))
    {
        V = Dequeue(Q);//输出V，或者记录V的输出序号;
        cnt++;
        for (V的每个邻接点w)
            if ( --Indegree[W] == 0)
                Enqueue(W,Q);
    }
    if (cnt != |V|)
       Error("图中有回路"); 
}
```

## 关键路径问题
### AOE网络
> 对于工序流程问题，那些绝对不允许延误的活动组成的路径称为关键路径(没有机动时间的项目)

![工序流程](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220116172955.png)
顶点之间的路径权重代表持续时间，
机动时间：最晚开始时间（从终点倒推)和最早开始时间不一致.$D_{<i,j>}=Latest[j] - Earliest[i] - E<i,j>$
![工序流程](https://markdown-img-1311240910.cos.ap-nanjing.myqcloud.com/QQ%e6%88%aa%e5%9b%be20220116174126.png)



